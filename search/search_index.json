{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DataStore2 is a simple to use data store system that caches, leading to significantly faster performance over traditional data stores. This documentation will show you how to use DataStore2 and configure it to your liking. If you find anything missing, file an issue on GitHub . Games that use DataStore2 Dungeon Quest - 600M+ visits Baldi's Basics - 140M+ visits Fairy World - 16.6M+ visits Do you want your game on here? File an issue on GitHub for it !","title":"Home"},{"location":"#games-that-use-datastore2","text":"Dungeon Quest - 600M+ visits Baldi's Basics - 140M+ visits Fairy World - 16.6M+ visits Do you want your game on here? File an issue on GitHub for it !","title":"Games that use DataStore2"},{"location":"api/","text":"Global Methods DataStore2 DataStore2(dataStoreName, player) -> DataStore Will create a DataStore instance for the player with that specific name. If one already exists, will retrieve that one. Warning Do not use the master key that you use in combined data stores, this behavior is not defined! DataStore2.Combine DataStore2.Combine(masterKey, ...keysToCombine) Combines all the keys under keysToCombine under the masterKey . Internally, will save all data under those keys into the masterKey as one large dictionary. You can learn more about combined data stores and why you should use them in the gotchas page . Can be called multiple times without overriding previously combined keys. Warning You should never use data stores without combining them or at the very least, replicating the behavior by creating one large dictionary yourself! Combined data stores will soon be the default way to use DataStore2 . DataStore2.ClearCache DataStore2.ClearCache() Clears the DataStore2 cache, so using DataStore2 again will give you fresh data stores. This is mostly for internal use or for unit testing. DataStore2.PatchGlobalSettings DataStore2.PatchGlobalSettings({ SavingMethod?: \"Standard\" | \"OrderedBackups\", }) Will override the global settings by patching it with ones you provide. This means if you do not specify a setting, it will not be changed. Current Settings SavingMethod (Default: \"OrderedBackups\") Controls how the data should be saved. Read more in the saving methods page . DataStore2.SaveAll DataStore2.SaveAll(player) Will save all the data stores of the player. This is the recommended way to save combined data stores. DataStore API DataStore:Get Get(defaultValue?: any, dontAttemptGet?: bool) -> any Will return the value cached in the data store, if it exists. If it does not exist, will then attempt to get the value from Roblox data stores. This function will only yield if there is no value in the data store. When a defaultValue is passed in, that value will be used if the player has no data. When dontAttemptGet is true , will return the cached value and will not attempt to get it from Roblox if it does not exist. Ignores the value of defaultValue . Note :Get() returns a deep copy of whatever the data is, thus if the value is a table, then dataStore:Get() ~= dataStore:Get() . This may be lifted in the future for \"pure\" data stores. DataStore:Set Set(newValue: any) Will set the cached value in the data store to newValue . Does not make any data store calls, and so will never yield. DataStore:Save Save() Saves the data in the current data store to Roblox. This function yields. Warning Currently, Save() does not attempt to retry if it fails the first time. Save() can error if data stores are down or your data is invalid. DataStore:Update Update(updateCallback: (any) => any) Will set the data store value to the return of updateCallback when passed with the current value. Bug Update currently does not attempt to get the value from the Roblox data store. This will be fixed in a future update. Notice You may see people talk about how UpdateAsync is more reliable than SetAsync in normal Roblox data stores. In DataStore2, this doesn't matter since neither actually call Roblox data store methods, so use :Set when you don't need the old value. DataStore:GetTable GetTable(default: Dictionary<any, any>) -> Dictionary<any, any> Will get the value (either from the cache or Roblox data stores), and patch it with the default value if it doesn't have the keys. For example, if you have the data: { coins = 0 , swords = {}, } ...and want to add a gems field, just appending on that to the default value for Get won't work the way you might want it too--it won't add the key! -- Oops! The player already has data, so it doesn't try to use the default value! dataStore : Get ({ coins = 0 , gems = 0 , swords = {}, }) You can, however, use GetTable : -- Much better! It'll check if they have each key rather than just if they have data. dataStore : GetTable ({ coins = 0 , gems = 0 , swords = {}, }) Note This is not necessary to use tables with DataStore2. You can save/retrieve tables just like any other piece of data. DataStore:Increment Increment(add: number, defaultValue?: number) Will increment the current value (cached or from Roblox data stores) with the value provided in add . If a value does not exist, will use defaultValue , then add. DataStore:OnUpdate OnUpdate(callback: (value: any) => void) Will call the callback provided whenever the cached value is updated. Is not called on the initial get. DataStore:SetBackup SetBackup(retries: number, alternativeDefaultValue?: any) Will set the number of retries for :Get() to attempt to retrieve a Roblox data store value before giving up and marking the data store as a backup. If alternativeDefaultValue is provided, then that value will be given to :Get() , otherwise normal rules apply while assuming the player actually doesn't have any data. Learn more on the backups page . DataStore:IsBackup IsBackup() -> bool Returns whether the current data store is a backup data store or not. Learn more on the backups page . Tip You don't need to know if a data store is a backup when saving . Backup data stores will never save. DataStore:ClearBackup ClearBackup() Unmarks the current data store as a backup data store. The next time Get() is called, it'll attempt to get the value inside Roblox data stores again. Learn more on the backups page . DataStore:BeforeInitialGet BeforeInitialGet(modifier: (dataValue: any) => any) Called after a value is received from Roblox data stores. The value returned is what :Get() will receive. Primarily used for deserialization. Learn more on the serialization page . Bug BeforeInitialGet is known to cause issues with combined data stores. If you can reproduce these issues, please file an issue on GitHub ! DataStore:BeforeSave BeforeSave(modifier: (dataValue: any) => any) Called before a value is saved into Roblox data stores. The value returned is what will be saved. Primarily used for serialization. Learn more on the serialization page . DataStore:AfterSave AfterSave(callback: (savedValue: any) => void) Will call the callback after data is successfully saved into Roblox data stores. DataStore:GetAsync GetAsync(defaultValue?: any, dontAttemptGet?: bool) -> Promise<any> Same as Get , but will instead return a Promise instead of yielding. DataStore:SaveAsync SaveAsync() -> Promise<bool, any> Same as Save , but will instead return a Promise instead of yielding. On rejection, will return the error that caused the reject. On resolution, will return whether the data actually saved. This is false in the case of being in studio, data not being updated or the data store being a backup store. Tip If you only want to be notified when the data is truly saved, use AfterSave . DataStore:GetTableAsync GetTableAsync(default: Dictionary<any, any>) -> Promise<Dictionary<any, any>> Same as GetTable , but will instead return a Promise instead of yielding. DataStore:IncrementAsync IncrementAsync(add: number, defaultValue?: number) -> Promise<void> Same as Increment , but will instead return a Promise instead of yielding.","title":"API"},{"location":"api/#global-methods","text":"","title":"Global Methods"},{"location":"api/#datastore2","text":"DataStore2(dataStoreName, player) -> DataStore Will create a DataStore instance for the player with that specific name. If one already exists, will retrieve that one. Warning Do not use the master key that you use in combined data stores, this behavior is not defined!","title":"DataStore2"},{"location":"api/#datastore2combine","text":"DataStore2.Combine(masterKey, ...keysToCombine) Combines all the keys under keysToCombine under the masterKey . Internally, will save all data under those keys into the masterKey as one large dictionary. You can learn more about combined data stores and why you should use them in the gotchas page . Can be called multiple times without overriding previously combined keys. Warning You should never use data stores without combining them or at the very least, replicating the behavior by creating one large dictionary yourself! Combined data stores will soon be the default way to use DataStore2 .","title":"DataStore2.Combine"},{"location":"api/#datastore2clearcache","text":"DataStore2.ClearCache() Clears the DataStore2 cache, so using DataStore2 again will give you fresh data stores. This is mostly for internal use or for unit testing.","title":"DataStore2.ClearCache"},{"location":"api/#datastore2patchglobalsettings","text":"DataStore2.PatchGlobalSettings({ SavingMethod?: \"Standard\" | \"OrderedBackups\", }) Will override the global settings by patching it with ones you provide. This means if you do not specify a setting, it will not be changed.","title":"DataStore2.PatchGlobalSettings"},{"location":"api/#current-settings","text":"SavingMethod (Default: \"OrderedBackups\") Controls how the data should be saved. Read more in the saving methods page .","title":"Current Settings"},{"location":"api/#datastore2saveall","text":"DataStore2.SaveAll(player) Will save all the data stores of the player. This is the recommended way to save combined data stores.","title":"DataStore2.SaveAll"},{"location":"api/#datastore-api","text":"","title":"DataStore API"},{"location":"api/#datastoreget","text":"Get(defaultValue?: any, dontAttemptGet?: bool) -> any Will return the value cached in the data store, if it exists. If it does not exist, will then attempt to get the value from Roblox data stores. This function will only yield if there is no value in the data store. When a defaultValue is passed in, that value will be used if the player has no data. When dontAttemptGet is true , will return the cached value and will not attempt to get it from Roblox if it does not exist. Ignores the value of defaultValue . Note :Get() returns a deep copy of whatever the data is, thus if the value is a table, then dataStore:Get() ~= dataStore:Get() . This may be lifted in the future for \"pure\" data stores.","title":"DataStore:Get"},{"location":"api/#datastoreset","text":"Set(newValue: any) Will set the cached value in the data store to newValue . Does not make any data store calls, and so will never yield.","title":"DataStore:Set"},{"location":"api/#datastoresave","text":"Save() Saves the data in the current data store to Roblox. This function yields. Warning Currently, Save() does not attempt to retry if it fails the first time. Save() can error if data stores are down or your data is invalid.","title":"DataStore:Save"},{"location":"api/#datastoreupdate","text":"Update(updateCallback: (any) => any) Will set the data store value to the return of updateCallback when passed with the current value. Bug Update currently does not attempt to get the value from the Roblox data store. This will be fixed in a future update. Notice You may see people talk about how UpdateAsync is more reliable than SetAsync in normal Roblox data stores. In DataStore2, this doesn't matter since neither actually call Roblox data store methods, so use :Set when you don't need the old value.","title":"DataStore:Update"},{"location":"api/#datastoregettable","text":"GetTable(default: Dictionary<any, any>) -> Dictionary<any, any> Will get the value (either from the cache or Roblox data stores), and patch it with the default value if it doesn't have the keys. For example, if you have the data: { coins = 0 , swords = {}, } ...and want to add a gems field, just appending on that to the default value for Get won't work the way you might want it too--it won't add the key! -- Oops! The player already has data, so it doesn't try to use the default value! dataStore : Get ({ coins = 0 , gems = 0 , swords = {}, }) You can, however, use GetTable : -- Much better! It'll check if they have each key rather than just if they have data. dataStore : GetTable ({ coins = 0 , gems = 0 , swords = {}, }) Note This is not necessary to use tables with DataStore2. You can save/retrieve tables just like any other piece of data.","title":"DataStore:GetTable"},{"location":"api/#datastoreincrement","text":"Increment(add: number, defaultValue?: number) Will increment the current value (cached or from Roblox data stores) with the value provided in add . If a value does not exist, will use defaultValue , then add.","title":"DataStore:Increment"},{"location":"api/#datastoreonupdate","text":"OnUpdate(callback: (value: any) => void) Will call the callback provided whenever the cached value is updated. Is not called on the initial get.","title":"DataStore:OnUpdate"},{"location":"api/#datastoresetbackup","text":"SetBackup(retries: number, alternativeDefaultValue?: any) Will set the number of retries for :Get() to attempt to retrieve a Roblox data store value before giving up and marking the data store as a backup. If alternativeDefaultValue is provided, then that value will be given to :Get() , otherwise normal rules apply while assuming the player actually doesn't have any data. Learn more on the backups page .","title":"DataStore:SetBackup"},{"location":"api/#datastoreisbackup","text":"IsBackup() -> bool Returns whether the current data store is a backup data store or not. Learn more on the backups page . Tip You don't need to know if a data store is a backup when saving . Backup data stores will never save.","title":"DataStore:IsBackup"},{"location":"api/#datastoreclearbackup","text":"ClearBackup() Unmarks the current data store as a backup data store. The next time Get() is called, it'll attempt to get the value inside Roblox data stores again. Learn more on the backups page .","title":"DataStore:ClearBackup"},{"location":"api/#datastorebeforeinitialget","text":"BeforeInitialGet(modifier: (dataValue: any) => any) Called after a value is received from Roblox data stores. The value returned is what :Get() will receive. Primarily used for deserialization. Learn more on the serialization page . Bug BeforeInitialGet is known to cause issues with combined data stores. If you can reproduce these issues, please file an issue on GitHub !","title":"DataStore:BeforeInitialGet"},{"location":"api/#datastorebeforesave","text":"BeforeSave(modifier: (dataValue: any) => any) Called before a value is saved into Roblox data stores. The value returned is what will be saved. Primarily used for serialization. Learn more on the serialization page .","title":"DataStore:BeforeSave"},{"location":"api/#datastoreaftersave","text":"AfterSave(callback: (savedValue: any) => void) Will call the callback after data is successfully saved into Roblox data stores.","title":"DataStore:AfterSave"},{"location":"api/#datastoregetasync","text":"GetAsync(defaultValue?: any, dontAttemptGet?: bool) -> Promise<any> Same as Get , but will instead return a Promise instead of yielding.","title":"DataStore:GetAsync"},{"location":"api/#datastoresaveasync","text":"SaveAsync() -> Promise<bool, any> Same as Save , but will instead return a Promise instead of yielding. On rejection, will return the error that caused the reject. On resolution, will return whether the data actually saved. This is false in the case of being in studio, data not being updated or the data store being a backup store. Tip If you only want to be notified when the data is truly saved, use AfterSave .","title":"DataStore:SaveAsync"},{"location":"api/#datastoregettableasync","text":"GetTableAsync(default: Dictionary<any, any>) -> Promise<Dictionary<any, any>> Same as GetTable , but will instead return a Promise instead of yielding.","title":"DataStore:GetTableAsync"},{"location":"api/#datastoreincrementasync","text":"IncrementAsync(add: number, defaultValue?: number) -> Promise<void> Same as Increment , but will instead return a Promise instead of yielding.","title":"DataStore:IncrementAsync"},{"location":"advanced/backups/","text":"Info This page is not to be confused with the ordered backups method of saving. This page is relevant no matter what saving method you choose. DataStore2 in the end always uses Roblox's data stores and servers. Not infrequently, these servers will go down through no fault of you. You need to be prepared for when this happens. Luckily, DataStore2 makes it easy. Let's say we have the following code: local coinsStore = DataStore2 ( \"coins\" , player ) print ( coinsStore : Get ( 0 )) By default, if data stores are down, DataStore2 will keep retrying until it gets a result. However, we may not want it to do that! If you write: local coinsStore = DataStore2 ( \"coins\" , player ) coinsStore : SetBackup ( 5 ) print ( coinsStore : Get ( 0 )) ...then DataStore2 will try to get the data five times before giving up. When DataStore2 \"gives up\", it'll pretend the player doesn't have any data at all. Thus, no matter how many coins the player has, since there's no way to recover that data it'll simply print they have 0 coins. However, don't worry! DataStore2 will mark this data store as a \"backup data store\". That means that it will never save . You wouldn't want it to save, it would override the player's actual data! If it's necessary, you can check if a data store is a backup data store with the :IsBackup() method. local coinsStore = DataStore2 ( \"coins\" , player ) coinsStore : SetBackup ( 5 ) print ( coinsStore : IsBackup ()) -- will print \"true\" if DataStore2 couldn't successfully get the data You can also clear a backup data store so that the next time you :Get(), DataStore2 will try to recover the data again. You do not need to reset the retry amount. coinsStore : ClearBackup ()","title":"Backups"},{"location":"advanced/saving_methods/","text":"DataStore2 supports two ways of storing data. You can tell DataStore2 which one to use by either editing the Settings module inside DataStore2, or by running the following command before creating any data stores: DataStore2 . PatchGlobalSettings ({ SavingMethod = \"SavingMethodGoesHere\" , }) \"OrderedBackups\" This is the default setting for DataStore2, and is partly responsible for its popularity. With this as the saving method, DataStore2 will use multiple data stores instead of just one. This ensures no data is lost, but is extremely redundant and uses a lot of storage on Roblox's side. This method was initially conceptualized by berezaa, which is why you'll sometimes hear this coloquially called the \"berezaa method\". \"Standard\" While this is the saving method, DataStore2 will instead just use normal data stores without any funny business. This is the recommended saving method if you are migrating an existing game to DataStore2. For example, if you use the key \"coins\" (assuming it's uncombined), DataStore2 will get your data simply with: DataStoreService : GetDataStore ( \"coins\" ): GetAsync ( player . UserId )","title":"Saving Methods"},{"location":"advanced/saving_methods/#orderedbackups","text":"This is the default setting for DataStore2, and is partly responsible for its popularity. With this as the saving method, DataStore2 will use multiple data stores instead of just one. This ensures no data is lost, but is extremely redundant and uses a lot of storage on Roblox's side. This method was initially conceptualized by berezaa, which is why you'll sometimes hear this coloquially called the \"berezaa method\".","title":"\"OrderedBackups\""},{"location":"advanced/saving_methods/#standard","text":"While this is the saving method, DataStore2 will instead just use normal data stores without any funny business. This is the recommended saving method if you are migrating an existing game to DataStore2. For example, if you use the key \"coins\" (assuming it's uncombined), DataStore2 will get your data simply with: DataStoreService : GetDataStore ( \"coins\" ): GetAsync ( player . UserId )","title":"\"Standard\""},{"location":"advanced/serde/","text":"Bug Deserialization is known to cause issues with combined data stores. If you can reproduce these issues, please file an issue on GitHub ! Data stores have a limit on how much they can save. While usually it doesn't matter, sometimes you're expecting to be saving a LOT of data, and you're going to want to save as little as possible. However, it's rare that the most optimal way to store data will be the most readable. Luckily, DataStore2 can help make this process invisible, so you save the most optimal form of your data while using the most readable. The process of saving data in an optimal, compressed format is called \"serialization\". Likewise, the process of taking compressed data and turning it into a format for humans is called \"deserialization\". Methods DataStore2 lets you easily serialize/deserialize data with BeforeInitialGet and BeforeSave . Simply put, BeforeInitialGet defines your deserializer, while BeforeSave defines your serializer. Here's how it works. Let's say we have an inventory system where a player can only have one of any item. Let's also suppose their data is saved like this: { [ \"Cool Sword\" ] = true , [ \"Doge Head\" ] = true , -- etc... } However, we run into an issue. The more items we add, the more data we have to save, and we might have some pretty long names in the future! [ \"The Totally Awesome Sword of Justice, Sponsored By Builderman\" ] = true , Ouch. Let's use serializers and deserializers to fix this. The best way to store our data is like this: { 1 , 6 , 8 } Huh? Numbers? Yep, but those numbers are going to correlate to items. We're going to create a dictionary of all the items in our game under the name \"ItemsDictionary\". It'll map item IDs to names . return { \"Cool Sword\" , \"Crazy Sword\" , \"Doge Head\" , -- etc } Now, we can write our serializer and deserializer. We're going to save as numbers, but come back the same place we were before. local itemsStore = DataStore2 ( \"items\" , player ) itemStore : BeforeInitialGet ( function ( serialized ) -- BeforeInitialGet is called the first time :Get() is, known as the \"initial get\". -- This is the only time DataStore2 will call the DataStoreService get method. -- The \"serialized\" argument is the value that was actually in the store. -- That means that right now, it's something like { 1, 6, 8 } -- What we return is what DataStore2 is going to give `:Get()`. local deserialized = {} for _ , id in pairs ( serialized ) do local itemName = ItemsDictionary [ id ] deserialized [ itemName ] = true end return deserialized end ) itemStore : BeforeSave ( function ( deserialized ) -- BeforeSave is called, well, before we save! -- The return is what DataStore2 will actually save, so we want it in the serialized form. local serialized = {} for itemName in pairs ( deserialized ) do for itemId , name in pairs ( ItemsDictionary ) do if name == itemName then table.insert ( serialized , itemId ) end end end return serialized end )","title":"Serialization"},{"location":"advanced/serde/#methods","text":"DataStore2 lets you easily serialize/deserialize data with BeforeInitialGet and BeforeSave . Simply put, BeforeInitialGet defines your deserializer, while BeforeSave defines your serializer. Here's how it works. Let's say we have an inventory system where a player can only have one of any item. Let's also suppose their data is saved like this: { [ \"Cool Sword\" ] = true , [ \"Doge Head\" ] = true , -- etc... } However, we run into an issue. The more items we add, the more data we have to save, and we might have some pretty long names in the future! [ \"The Totally Awesome Sword of Justice, Sponsored By Builderman\" ] = true , Ouch. Let's use serializers and deserializers to fix this. The best way to store our data is like this: { 1 , 6 , 8 } Huh? Numbers? Yep, but those numbers are going to correlate to items. We're going to create a dictionary of all the items in our game under the name \"ItemsDictionary\". It'll map item IDs to names . return { \"Cool Sword\" , \"Crazy Sword\" , \"Doge Head\" , -- etc } Now, we can write our serializer and deserializer. We're going to save as numbers, but come back the same place we were before. local itemsStore = DataStore2 ( \"items\" , player ) itemStore : BeforeInitialGet ( function ( serialized ) -- BeforeInitialGet is called the first time :Get() is, known as the \"initial get\". -- This is the only time DataStore2 will call the DataStoreService get method. -- The \"serialized\" argument is the value that was actually in the store. -- That means that right now, it's something like { 1, 6, 8 } -- What we return is what DataStore2 is going to give `:Get()`. local deserialized = {} for _ , id in pairs ( serialized ) do local itemName = ItemsDictionary [ id ] deserialized [ itemName ] = true end return deserialized end ) itemStore : BeforeSave ( function ( deserialized ) -- BeforeSave is called, well, before we save! -- The return is what DataStore2 will actually save, so we want it in the serialized form. local serialized = {} for itemName in pairs ( deserialized ) do for itemId , name in pairs ( ItemsDictionary ) do if name == itemName then table.insert ( serialized , itemId ) end end end return serialized end )","title":"Methods"},{"location":"guide/basic_usage/","text":"DataStore2 is meant to be easy to use. The basic usage can be seen from the following example code. The code below does the following: - Fires a remote event called \"CoinAmount\" to players when they join and when their amount of coins updates. - Listens for a \"BuyProduct\" remote to let players buy products. - Buying products reduces their amount of coins, which will then fire the remote event. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local ServerScriptService = game : GetService ( \"ServerScriptService\" ) local DataStore2 = require ( ServerScriptService . DataStore2 ) -- Always \"combine\" any key you use! To understand why, read the \"Gotchas\" page. DataStore2 . Combine ( \"DATA\" , \"coins\" ) Players . PlayerAdded : Connect ( function ( player ) local coinStore = DataStore2 ( \"coins\" , player ) local function callRemote ( value ) ReplicatedStorage . CoinAmount : FireClient ( player , value ) end -- Fire a remote event to the player telling them how many coins they have. -- If this is their first time playing the game, they'll start out with 100. callRemote ( coinStore : Get ( 100 )) -- Everytime the coin store updates, we'll send the RemoteEvent again. coinStore : OnUpdate ( callRemote ) end ) -- This is a RemoteEvent where a player can purchase a product by its name. local Products = require ( ReplicatedStorage . Products ) ReplicatedStorage . BuyProduct . OnServerEvent : connect ( function ( player , productName ) if not Products [ productName ] then return end -- Make sure the player is buying a real product local coinStore = DataStore2 ( \"coins\" , player ) local productPrice = Products [ productName ]. price if coinStore : Get ( 100 ) >= productPrice then print ( \"Buying product\" , productName ) coinStore : Increment ( - productPrice ) end end )","title":"Basic Usage"},{"location":"guide/gotchas/","text":"You need to set your data stores as they change , not on PlayerRemoving. The normal way of doing data stores is to keep a cache somewhere of a player's data (such as in a folder or using leaderstats), then saving when the player leaves. It is wrong, however, to use DataStore2 this way . DataStore2 is built to be used whenever your data actually changes. You shouldn't invoke DataStore2 in PlayerRemoving at all . Don't worry, :Set will never error or do API calls, it's all cached. DataStore2 will save the player's data before they leave. Because of the throttles on OrderedDataStores, DataStore2 (with the default saving method) is only guaranteed to not throttle on :Get() if you use less than 2 unique keys. In normal data stores, you'd save all your data into one giant player data table to minimize data loss/throttling. In DataStore2, this is a built in feature! Simply use DataStore2.Combine(\"DATA\", \"any\", \"keys\", \"here\") , or call it multiple times ( DataStore2.Combine(\"DATA\", \"coins\"); DataStore2.Combine(\"DATA\", \"guns\") ). These are called \"combined data stores\", they save all your data into one big table but without the cost of ergonomics (you don't have to get the entire data just to manipulate one part of it). The \"DATA\" is what the data will combine under internally. If you are migrating an existing game (and have made sure to set your saving method to Standard), this will be whatever your large data table is already called. In the future, combined data stores will become the default, but for now you must explicitly define every key you use, or be at risk of heavy throttling.","title":"Gotchas"},{"location":"guide/installation/","text":"There are a few recommended ways to get DataStore2 into your game. It is recommended that however way you get it, you put it in ServerScriptService , as you can only use DataStore2 on the server anyway. Method 1: Model File (Roblox Studio) Download the rbxmx model file attached to the latest release from the GitHub releases page . Insert the model into Studio into ServerScriptService . Method 2: Filesystem Copy the DataStore2 directory into your codebase Use Rojo to sync the files into your place","title":"Installation"},{"location":"guide/installation/#method-1-model-file-roblox-studio","text":"Download the rbxmx model file attached to the latest release from the GitHub releases page . Insert the model into Studio into ServerScriptService .","title":"Method 1: Model File (Roblox Studio)"},{"location":"guide/installation/#method-2-filesystem","text":"Copy the DataStore2 directory into your codebase Use Rojo to sync the files into your place","title":"Method 2: Filesystem"},{"location":"guide/simulator/","text":"In this example, we're going to create a basic \"simulator\" game. If you do not have DataStore2 installed, read the installation guide . In our game, we're going to have a brick that when a player clicks on it, they'll get points. After installing DataStore2, create a \"Part\" in the workspace, then put a \"ClickDetector\" inside of it. Name the part something like PointsPart. Your workspace should look like this: Next, we're going to create a leaderstats board. Create a script in ServerScriptService with the following code. local Players = game : GetService ( \"Players\" ) local ServerScriptService = game : GetService ( \"ServerScriptService\" ) local Workspace = game : GetService ( \"Workspace\" ) local DataStore2 = require ( ServerScriptService . DataStore2 ) -- Combine every key you use. This will eventually be the default, but for now read the \"Gotchas\" section to understand why we need this. DataStore2 . Combine ( \"DATA\" , \"points\" ) Players . PlayerAdded : Connect ( function ( player ) local pointsStore = DataStore2 ( \"points\" , player ) local leaderstats = Instance . new ( \"Folder\" ) leaderstats . Name = \"leaderstats\" local points = Instance . new ( \"NumberValue\" ) points . Name = \"Points\" points . Value = pointsStore : Get ( 0 ) -- The \"0\" means that by default, they'll have 0 points points . Parent = leaderstats pointsStore : OnUpdate ( function ( newPoints ) -- This function runs every time the value inside the data store changes. points . Value = newPoints end ) leaderstats . Parent = player end ) Click \"Play\", and look at the top right of your screen. You should see this: Now, we have to let the player actually get points. Write the following code after the connection: Workspace . PointsPart . ClickDetector . MouseClick : Connect ( function ( player ) local pointsStore = DataStore2 ( \"points\" , player ) pointsStore : Increment ( 1 ) -- Give them 1 point end ) Go in game, and click the brick to your heart's content. You should be getting points! If you play your game on roblox.com, you'll be able to get points, leave, come back, and the points you had last time should save! However, you'll notice that if you play the game in studio , your points won't save. This is because DataStore2 does not save in studio by default . Usually, you don't want to save in studio because you don't want broken data while you're developing, and you don't want to have to wait for your data to save every time. However, you can change this yourself. Create a \"BoolValue\" in ServerStorage named \"SaveInStudio\". It should look like this: Now, make sure the checkbox is checked. You'll now be able to play over and over again as much as you want, and your data will save!","title":"Basic Example: Simulator"}]}